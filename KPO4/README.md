# KPO 4

Проект представляет собой прототип распределенной системы электронной коммерции, построенной на микросервисной архитектуре. Система реализует полный цикл обработки заказа: от создания пользователем до асинхронной обработки платежа и обновления статуса.

Основной упор сделан на обеспечение надежности распределенных транзакций и гарантии доставки сообщений между сервисами.

## Используемые технологии

*   **Платформа:** .NET 8 (C#)
*   **База данных:** PostgreSQL
*   **Брокер сообщений:** RabbitMQ
*   **ORM:** Entity Framework Core
*   **Контейнеризация:** Docker, Docker Compose
*   **API Gateway:** Ocelot
*   **Frontend:** HTML/JS (Fetch API), Nginx

## Архитектура решения

Система состоит из четырех основных компонентов, разворачиваемых в Docker-контейнерах:

### 1. API Gateway
Единая точка входа для всех внешних запросов. Реализован на базе Ocelot.
*   Маршрутизирует запросы от фронтенда к соответствующим микросервисам.
*   Скрывает внутреннюю структуру сети от клиента.

### 2. Order Service
Микросервис управления заказами.
*   **Функциональность:** Создание заказа, просмотр списка заказов пользователя, отслеживание статуса.
*   **Паттерны:**
    *   *Transactional Outbox:* При создании заказа запись в БД и событие для брокера сохраняются в одной транзакции. Это гарантирует, что событие не потеряется, даже если процесс упадет сразу после коммита в БД.
    *   *Background Publisher:* Фоновый сервис читает таблицу `OutboxMessages` и отправляет события в RabbitMQ.

### 3. Payments Service
Микросервис управления счетами и транзакциями.
*   **Функциональность:** Создание счета, пополнение баланса, списание средств.
*   **Паттерны:**
    *   *Idempotent Consumer:* Обработка входящих сообщений о создании заказа идемпотентна. Повторная обработка того же сообщения не приведет к двойному списанию.
    *   *Transactional Inbox/Outbox:* Входящее сообщение сохраняется и обрабатывается атомарно с изменением баланса и созданием исходящего события (результат оплаты).

### 4. Frontend
Веб-интерфейс для взаимодействия с системой.
*   Реализован как SPA (Single Page Application) на чистом JS.
*   Позволяет создавать счета, оформлять заказы и наблюдать за изменением их статусов в реальном времени (через поллинг статуса).
*   Обслуживается сервером Nginx.

## Логика взаимодействия

1.  **Создание заказа:** Клиент отправляет POST-запрос через Gateway в Order Service.
2.  **Outbox Pattern:** Order Service сохраняет заказ со статусом `Created` и запись в Outbox-таблицу в рамках одной транзакции PostgreSQL.
3.  **Публикация:** Фоновый воркер Order Service отправляет событие `OrderCreated` в очередь RabbitMQ.
4.  **Обработка оплаты:** Payment Service обрабатывает входящее сообщение. В случае успешного списания средств формируется и отправляется событие подтверждения оплаты.

5.  **Завершение:** Order Service получает результат оплаты из RabbitMQ и обновляет статус заказа на `Finished` или `Cancelled`.

## Запуск проекта

Для запуска требуется установленный Docker и Docker Compose.

1.  Клонируйте репозиторий.
2.  Перейдите в корневую директорию решения.
3.  Выполните команду сборки и запуска:

`docker-compose up --build`


Система развернет следующие контейнеры:
*   `KPO4` (PostgreSQL) — порт 5432
*   `rabbitmq` — порт 5672 (UI на 15672)
*   `orderservice`
*   `paymentsservice`
*   `apigateway` — порт 5005
*   `frontend` — порт 3000

### Доступ к интерфейсу

После успешного запуска веб-интерфейс доступен по адресу:
[**http://localhost:3000**](http://localhost:3000)

### Сценарий тестирования
1.  Открыть веб-интерфейс.
2.  Нажать "Создать счет" (баланс по умолчанию 5000).
3.  В блоке "Новый заказ" нажать "Оформить заказ".
4.  Наблюдать в логе смену статуса с `Created` на `Finished` (или `Cancelled`, если сумма заказа, сгенерированная случайно, превысила баланс).

## Особенности реализации

*   **Handling Concurrency:** Для работы с балансом и статусами заказов используются транзакции БД уровня ReadCommitted.
*   **Resiliency:** Сервисы настроены на перезапуск (`restart: always`) и ожидают готовности инфраструктуры (HealthChecks для RabbitMQ и Postgres) перед стартом.
*   **Конфигурация:** Все параметры подключения вынесены в переменные окружения `docker-compose.yml`.
